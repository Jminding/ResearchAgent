# Surface Code: Detailed Mathematical Framework and Distance-3 Configuration

## Mathematical Foundations

### Stabilizer Code Theory

A stabilizer code is defined by an abelian subgroup S of the n-qubit Pauli group P_n, called the stabilizer group.

**Definition:** The code space is the +1 eigenspace of all stabilizer generators:
```
C = {|ψ⟩ : g|ψ⟩ = |ψ⟩ for all generators g ∈ S}
```

**Key Property:** The stabilizer group S is generated by a set of independent commuting Pauli operators called stabilizer generators.

**Code Parameters:** An [[n, k, d]] code encodes k logical qubits using n physical qubits and has distance d, where:
- n: total number of physical qubits
- k: number of logical qubits encoded
- d: minimum weight of undetectable error (distance)

**Relation:** k = n - log₂|S| for abelian stabilizer codes.

### CSS Codes (Calderbank-Shor-Steane)

CSS codes separate X and Z errors through independent stabilizer sectors.

**Structure:**
- X-stabilizers: commute with Z logical operators, detect Z errors
- Z-stabilizers: commute with X logical operators, detect X errors
- All X and Z stabilizers mutually commute

**Advantage:** Enables independent syndrome extraction for bit-flip and phase-flip errors.

### Logical Operators

For a [[n, k, d]] code with stabilizer group S:

**Logical Operators L = {l₁, l₁', l₂, l₂', ..., l_k, l_k'}:**
- Each logical qubit j has two operators: l_j (X-type) and l_j' (Z-type)
- Commutation: [l_j, S] = 0 (commute with all stabilizers)
- But l_j ∉ S (not in stabilizer group)
- Commutation: [l_j, l_j'] = 0 or {l_j, l_j'} = 0 depending on encoding
- Anticommutation: l_j and l_j'' anticommute for j ≠ j''

**Example (Surface Code):**
- Logical X₁: non-contractible loop of X operators on rough boundary path
- Logical Z₁: non-contractible loop of Z operators on smooth boundary path

---

## Surface Code 2D Lattice Structure

### Standard (Square Lattice) Surface Code

**Physical Qubit Placement:**
- Qubits located at edges of a square lattice
- For an m × m checkerboard: (2m)² = 4m² data qubits
- Ancilla syndrome qubits at vertices/plaquettes for measurement

**Lattice Orientation:**
```
        ----- qubit -----
        |               |
    vertex            plaquette
        |               |
        ----- qubit -----
```

**Grid Specification (Distance-d code):**
- Code distance d = 2m + 1
- Physical lattice: (2m+1) × (2m+1) arrangement
- For distance-3: m = 1, so 3×3 arrangement needed
- For distance-5: m = 2, so 5×5 arrangement needed

### Rotated Surface Code

**Geometry:** Qubits placed at lattice vertices of a rotated (45°) square lattice.

**Configuration (Distance-d):**
- Size: (2m+1) × (2m+1) vertices, where d = 2m + 1
- Total physical qubits: (2m+1)² = d²
- Stabilizer weight: all 2 or 4 (vs. mixed in standard code)

**Distance-3 Rotated Code:**
```
        d — d
        |   |
    X-stab Z-stab
        |   |
        d — d
```
- 3×3 = 9 physical qubits arranged in diamond pattern
- 4 X-stabilizers (plaquettes)
- 4 Z-stabilizers (stars)
- Boundaries: 2 rough + 2 smooth (opposite pairs)

### Planar vs. Toric Geometry

**Toric Code (Periodic BC):**
- Topology: 2-dimensional torus (handles both X and Z wrap-around cycles)
- Encodes: k = 2 logical qubits
- Stabilizers: all weight-4
- Physical qubits: 2n² for period-n lattice

**Planar Surface Code (Open BC):**
- Topology: 2D plane with boundaries
- Encodes: k = 1 logical qubit
- Boundary types: rough and smooth
- Physical qubits: ~d² for distance-d code
- More practical for physical implementation

---

## Stabilizer Operators in Depth

### X-Stabilizers (Plaquette Operators)

**Definition (Standard Code):**
For each plaquette p, the X-stabilizer X_p is:
```
X_p = X_{e₁} ⊗ X_{e₂} ⊗ X_{e₃} ⊗ X_{e₄}
```
where e₁, e₂, e₃, e₄ are the four edges surrounding plaquette p.

**Properties:**
- Eigenvalues: +1 (no error) or -1 (error present)
- Measurement: Non-destructive via ancilla measurement
- Weight: 4 in bulk, 2 or 3 at boundaries

**Topological Interpretation:**
- X-stabilizers detect Z errors (bit-flip errors)
- Violation indicates odd number of Z errors within plaquette
- Multiple violations create "error string" paths

### Z-Stabilizers (Star Operators)

**Definition (Standard Code):**
For each vertex v, the Z-stabilizer Z_v is:
```
Z_v = Z_{e₁} ⊗ Z_{e₂} ⊗ Z_{e₃} ⊗ Z_{e₄}
```
where e₁, e₂, e₃, e₄ are the four edges incident to vertex v.

**Properties:**
- Eigenvalues: +1 or -1
- Measurement: Via syndrome qubit coupling
- Weight: 4 in bulk, 2 or 3 at boundaries

**Topological Interpretation:**
- Z-stabilizers detect X errors (phase-flip errors)
- Violation indicates odd number of X errors touching vertex
- Violations appear as anyonic charges

### Rotated Code Stabilizers

**Weight-2 Operators** (boundary and intermediate):
```
Example Z-stab (boundary): Z_q₁ ⊗ Z_q₂
Example X-stab (boundary): X_q₁ ⊗ X_q₂
```

**Weight-4 Operators** (bulk):
```
X-stab: X_q₁ ⊗ X_q₂ ⊗ X_q₃ ⊗ X_q₄
Z-stab: Z_q₁ ⊗ Z_q₂ ⊗ Z_q₃ ⊗ Z_q₄
```

**Uniformity:** All stabilizer weights are 2 or 4, independent of lattice size (key advantage over standard code).

---

## Parity Checks and Syndrome Extraction

### Syndrome Vector Definition

**Syndrome:** A binary vector s = [s₁, s₂, ..., s_m] where m = number of stabilizers.

**Entry:** s_i = 0 if stabilizer i measures +1; s_i = 1 if measures -1.

**Information Content:**
- Syndrome pattern reveals error location and type
- Different error configurations yield different syndromes
- Decoder must invert relationship: syndrome → most likely error

### Parity Check Matrix (CSS Framework)

For a CSS code with X and Z stabilizers:

**X-parity check matrix H_X:**
- Rows: X-stabilizer generators
- Columns: qubits
- Entry: 1 if qubit i appears in stabilizer j, 0 otherwise
- Syndrome: s_X = H_X · e_Z (mod 2)

**Z-parity check matrix H_Z:**
- Rows: Z-stabilizer generators
- Columns: qubits
- Syndrome: s_Z = H_Z · e_X (mod 2)

**Commutation Relation:**
```
[H_X, H_Z]^T = 0  (all rows commute)
```

### Syndrome Extraction Procedure

**Standard Protocol (4-5 rounds of entangling gates):**

1. **Initialize Ancilla:** Ancilla qubit q_anc → |0⟩
2. **Preparation Gate:** H on ancilla for Z-measurement; already in computational basis for X-measurement
3. **Entangle (Weight-4):** Four controlled-Z (or controlled-X) gates:
   - C-Z(q_anc, e₁), C-Z(q_anc, e₂), C-Z(q_anc, e₃), C-Z(q_anc, e₄)
   - Gate depth: 2 layers (can parallelize)
4. **Inverse Prep:** H on ancilla (if needed)
5. **Measure:** Measure ancilla in computational basis; result is syndrome bit

**Circuit Depth:** O(1) in qubit-qubit interaction distance. Typically 4-5 CNOT/CZ layers per syndrome cycle.

**Fidelity Considerations:**
- Each gate contributes error: typical ~10⁻³ per gate
- Syndrome extraction fidelity: ~(1-4×10⁻³)⁴ ≈ 98.4% for 4 gates
- Requires gates with fidelity >99% for fault tolerance

### Repeated Syndrome Measurement

**Temporal Dimension:**
- Measure syndromes T times (typically T ≈ d)
- Creates 3D spacetime graph: spatial 2D lattice + T temporal steps
- Errors manifest as paths in spacetime

**Syndrome Tracking:**
- Syndrome values change when errors occur
- Syndrome differences reveal error locations in spacetime
- Static syndrome violations during initialization and final measurement

---

## Logical Qubit Encoding

### Distance-3 Rotated Code Configuration

**Notation:** [[9, 1, 3]]

**Physical Layout:**
```
    D       D
     \     /
      X — Z
     /     \
    D       D
   /|\     /|\
  / | \   / | \
 D  |  X-Z  |  D
  \ | /   \ | /
   \|/     \|/
    D       D
     \     /
      X — Z
     /     \
    D       D
```

- 9 physical data qubits
- 4 X-stabilizers (weight 2-4)
- 4 Z-stabilizers (weight 2-4)
- Additional ~8 syndrome measurement qubits

**Boundary Configuration:**
```
Rough boundaries (left & right): X-logical termination
Smooth boundaries (top & bottom): Z-logical termination
```

### Distance-3 Planar Code Configuration

**Notation:** [[17, 1, 3]] or [[21, 1, 3]]

**Physical Layout:**
- 17 data qubits (plus syndrome qubits)
- Full 4-weight stabilizers in bulk
- Reduced-weight stabilizers at boundaries
- Larger spatial footprint than rotated code

**Practical Implementation:** Used in Google's Sycamore experiments demonstrating below-threshold error correction.

### Logical Operators for Distance-3

**Logical X Operator:**
```
Path of X operations on rough boundary
Length = code distance = 3 minimum
Commutes with all Z stabilizers
Anticommutes with logical Z
```

**Logical Z Operator:**
```
Path of Z operations on smooth boundary
Length = code distance = 3 minimum
Commutes with all X stabilizers
Anticommutes with logical X
```

**Error Correction Capability:**
- Single arbitrary error anywhere: correctable
- Two arbitrary errors: correctable if they don't create undetectable path
- Three or more errors: may not be correctable

### Distance-5 Configuration

**Notation:** [[25, 1, 5]] (rotated)

**Scaling:** 5×5 physical qubits
- 25 data qubits
- 12 X-stabilizers
- 12 Z-stabilizers
- ~12-16 syndrome qubits

**Error Correction:** Correct up to 2 arbitrary errors; higher confidence detection of 3+ errors.

**Experimental Significance:** Google's 2022 work showed 40-50% error reduction comparing distance-5 to distance-3, demonstrating below-breakeven error correction.

---

## Anyonic Excitations and Error Correction

### Anyonic Quasi-Particles

**Magnetic Charge (m-anyon):**
- Created by Z error (bit-flip)
- Detected by violation of Z-stabilizer (star)
- Topologically confined: cannot move without creating more violations
- Point-like excitation

**Electric Charge (e-anyon):**
- Created by X error (phase-flip)
- Detected by violation of X-stabilizer (plaquette)
- Topologically confined
- Point-like excitation

**Fermionic Composite (ψ-anyon):**
- e-m pair; behaves as fermion
- Non-trivial braiding statistics

### Error String Formation

**Z Error String:**
```
Error: Z at multiple qubits forming path
Manifestation: m-anyons at endpoints of path
Recovery: Apply Z errors to recreate path and annihilate anyons
```

**Syndrome Pattern:**
- Endpoint 1: violation of Z-stab at location (x₁, y₁)
- Endpoint 2: violation of Z-stab at location (x₂, y₂)
- Path: sequence of Z errors connecting the two violated stabilizers

### Topological Error Detection

**Trivial (Contractible) Loop:**
- Error string forms closed loop (endpoints coincide)
- All anyons annihilate
- State returns to valid codespace: error corrected

**Non-Trivial (Non-Contractible) Loop:**
- Error string wraps around non-trivial topology (in bulk codes)
- For planar code: string reaches boundary without being corrected
- Endpoint anyons annihilate but logical operator applied
- Uncorrected logical error if undetected

**Code Distance Definition:**
```
d = minimum weight of error that:
    1. Creates detectable syndrome, AND
    2. Applies logical operator l_x or l_z
```

For planar surface code:
```
d_x = minimum weight path connecting two smooth boundaries
d_z = minimum weight path connecting two rough boundaries
d = min(d_x, d_z)
```

For distance-d code: d = 2m + 1 where lattice has characteristic size 2m+1.

---

## Decoding: Mathematical Framework

### Minimum Weight Perfect Matching (MWPM)

**Problem Formulation:**
Given syndrome vector s (locations of violated stabilizers), find error e that:
1. Reproduces syndrome: H·e = s (mod 2)
2. Minimizes error weight: ||e|| = Σ|e_i|
3. Matches all syndrome violations perfectly

**Graph Construction:**
- Nodes: violation locations + virtual boundary node
- Edges: possible error paths between violations
- Edge weight: W(u,v) = -log[P(error from u to v)] ∝ path length × error rate

**Matching Problem:**
```
Find perfect matching M that minimizes:
Σ W(u,v) for all (u,v) ∈ M
```

**Feasibility:** Solvable in polynomial time O(n³) for n nodes.

**Performance:** Achieves ~1% threshold; proven optimal for certain error models.

### Threshold Theorem

**Theoretical Result (Dennis et al., Fowler et al.):**

For independent error rate p < p_th:
```
Logical error probability: P_L(d, p) ≈ A(p/p_th)^((d+1)/2)
```

where:
- A: constant factor (~0.1)
- p_th: threshold error rate (~1% for surface code)
- d: code distance

**Implication:** Below threshold, logical error rate decreases exponentially with distance.

**Example (p = 0.5% < p_th = 1%):**
- Distance-3: P_L ≈ 0.1 × (0.5)² ≈ 0.025
- Distance-5: P_L ≈ 0.1 × (0.5)³ ≈ 0.0125
- Distance-7: P_L ≈ 0.1 × (0.5)⁴ ≈ 0.00625
- Exponential suppression with distance

---

## Boundary Types and Topological Properties

### Smooth Boundaries (Z-Type)

**Definition:** Z-stabilizers (star operators) are truncated at boundary.

**Consequence:**
- Some data qubits at boundary have fewer Z-stabilizers coupling them
- Z-errors at boundary have reduced detection
- Logical Z operator can terminate on smooth boundary without detected violation

**Physical Realization:**
```
Regular interior: Z—o—Z  (two Z-stab per data qubit)
          |
          o  (data qubit coupling to Z-stab above and below)
          |
      Z—o—Z

Boundary:     Z—o  (only one Z-stab below)
              |
              o  (data qubit at edge)
```

### Rough Boundaries (X-Type)

**Definition:** X-stabilizers (plaquette operators) are truncated at boundary.

**Consequence:**
- Some data qubits at boundary have fewer X-stabilizers
- X-errors at boundary have reduced detection
- Logical X operator can terminate on rough boundary

**Physical Layout:**
```
Interior:  —o—  (four X-plaquette terms per data qubit)

Boundary:  —o  (fewer plaquette couplings)
```

### Mixed/Hybrid Boundaries

Some surface code variants use:
- All four sides smooth (boundary for Z-logical info)
- Three sides rough, one smooth (asymmetric)
- Custom boundary patterns for specific logical operations

**Topological Consequence:**
- Number and type of logical qubits depends on boundary configuration
- Toric code (periodic): 2 logical qubits
- Planar code (rough+smooth): 1 logical qubit
- Hybrid: 1.5 effective logical qubits (non-integer in certain sense)

---

## Quantitative Distance-3 Summary

### Physical Qubit Count
| Configuration | Data | X-Stab | Z-Stab | Syndrome | Total |
|---|---|---|---|---|---|
| Rotated [[9,1,3]] | 9 | 4 | 4 | ~8 | ~25 |
| Planar [[17,1,3]] | 17 | 6-8 | 6-8 | ~12 | ~45 |

### Error Correction Capability
- **Single-qubit error:** All correctable
- **Two-qubit errors:** Correctable unless creating undetectable pair on same axis
- **Three+ errors:** Depends on pattern and decoder algorithm

### Threshold Distance-3
- Physical error rate must be <1% for below-breakeven
- At p=0.5%: Logical error rate ~2.5%
- At p=0.1%: Logical error rate ~0.025%

### Experimental Timelines (typical)
- Syndrome extraction: ~1 microsecond per round
- T rounds (T=3 for d=3): ~3 microseconds per correction cycle
- Data qubit coherence: ~100+ microseconds (T2 time)
- Sufficient margin for error correction

---

## Key Formulae Summary

| Concept | Formula | Interpretation |
|---|---|---|
| Code Parameters | [[n,k,d]] | n qubits, k logical, distance d |
| Distance Definition | d = min(d_x, d_z) | min path length for undetectable logical error |
| Stabilizer Weight | weight(g) = number of single-qubit Paulis | affects measurement circuit depth |
| Threshold | p_th ≈ 0.57-1.1% | error rate below which correction improves |
| Logical Error | P_L(d,p) ≈ A(p/p_th)^((d+1)/2) | exponential in distance below threshold |
| Physical Overhead | ~10³-10⁴ per logical qubit | at useful error rates |
| Code Rate | R = k/n → 0 | inverse distance scaling for surface code |

---

## References for Mathematical Framework

1. Dennis, E., Kitaev, A., Landahl, A., & Preskill, J. (2002). "Topological quantum memory." Journal of Mathematical Physics, 43(9), 4452-4505.

2. Fowler, A. G., Mariantoni, M., Martinis, J. M., & Cleland, A. N. (2012). "Surface codes: Towards practical large-scale quantum computation." Reports on Progress in Physics, 75(8), 082001.

3. Calderbank, A. R., Shor, P. W., & Steane, A. M. (1997). "Good quantum error-correcting codes exist." Physical Review Letters, 78(3), 405.

4. Gottesman, D. (1997). "Stabilizer codes and quantum error correction." PhD dissertation, Caltech. arXiv:quant-ph/9705052.

5. Error Correction Zoo. "Kitaev surface code." https://errorcorrectionzoo.org/c/surface

6. Arthur Pesah. "An interactive introduction to the surface code." https://arthurpesah.me/blog/2023-05-13-surface-code/

